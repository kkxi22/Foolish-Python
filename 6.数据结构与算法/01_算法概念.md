# 数据结构与算法基本概念

数据结构与算法的确不容易学，需要的是毅力。

**看了网上很多血经验，无外乎总结起来就是：`掌握基础`+`刷题`**

因此我会先做基础知识笔记，然后更新刷题笔记，刷题最重要的是掌握思路，如果你看到一个新题，瞬间有两个以上的思路怎么结题，你就成功了。

**为什么要学？数据结构是一名程序猿必备的基本功，面试笔问，也是加分点。**

## 基础概念

思考一个问题
$$
a + b + c = 1000， a^2 + b^2 = c^2 （a,b,c都是自然数）求abc所有的组合。
$$


#### 什么是算法？

定义：**算法是一种独立解决问题的方法和思想，重点在`方法和思想`**

上面的思考该怎么解决呢？

**算法分析**：`abc`都在`0~1000`，并且都是自然数，计算机本来就是**傻瓜式计算**，只不过计算比较快而已。那就让计算机一个一个数试，`abc`遍历循环`0~1000`内，只要存在满足要求的就打印出来。

**算法方法**：

``` python
import time

start_time = time.time()  # 开始时间
for a in range(0, 1000):  # 遍历a
    for b in range(0, 1000):  # 遍历b
        for c in range(0, 1000):  # 遍历c
            if a*a + b*b == c*c and a + b + c == 1000:  # 计算是否达到要求
                print("a:%d,b:%d,c:%d" % (a, b, c))  # 打印输出
end_time = time.time()  # 结束时间
print("总计用时%f秒" % (end_time - start_time))  # 计算时间
```

> 结果
> a:0,b:500,c:500
> a:200,b:375,c:425
> a:375,b:200,c:425
> a:500,b:0,c:500
> 总计用时422.958450秒

**算法思想**：上面的分析和方法，就是解决问题的过程，是一种思想。**对于算法而言，实现语言并不重要，重要的是过程，方法和思想**

**总结**：算法是指对解决问题的方案准确而完整的描述，这个方案是解决问题的一系列指令。算法是计算机处理信息的本质，本身计算机就是一个算法，用户通过输入，让计算机获取数据并处理数据。

就比如上面的思考，**算法分析**就是对这个问题的完整描述，编写程序下达指令，**指令1**—`a`先从`0~100`，**指令2**—`b`先从`0~100`,**指令3**—`c`先从`0~100`,**指令4**—计算`abc和`以及平方是否相等，**指令5**—打印输出数据。

#### 算法的五个重要特张

1. **有穷性**：算法必须在执行有限个步骤后终止； 例如：代码死循环就不会停止。
2. **确切性**：算法每个步骤都要有明确的意义；
3. **输入项**：一个算法有0个或多个输入，也就是初始条件；
4. **输出项**：一个算法有一个或多个输出，没有输出的算法是没有意义的；
5. **可行性**：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）。

#### 算法优劣的衡量

上面的思考问题，我用了`422.958450秒`，如果计算机性能好，结果会快点。

**下面用第二种方法解决上面问题**

**算法分析**：`abc`都在`0~1000`，可以让`ab`循环，因为`c = 1000 -a - b`，就可以只需要两次循环。

**算法方法**：

``` python
import time

start_time = time.time()  # 开始时间
for a in range(0, 1000):  # 遍历a
    for b in range(0, 1000):  # 遍历b
        c = 1000 - a - b   # 计算c的值
        if a*a + b*b == c*c:  # 计算是否达到要求
            print("a:%d,b:%d,c:%d" % (a, b, c))  # 打印输出
end_time = time.time()  # 结束时间
print("总计用时%f秒" % (end_time - start_time))  # 计算时间
```

> 结果
> a:0,b:500,c:500
> a:200,b:375,c:425
> a:375,b:200,c:425
> a:500,b:0,c:500
> 总计用时0.523703秒

**结果只用了`0.523703秒`，远远小于`422.958450秒`，只改变了两行代码。**

所以算法是存在优劣的，如何评价算法的好坏呢？

同一个问题可以用不同的算法解决，算法的优劣，就相当于好的算法工程师年薪百万，而不好的，月薪5k。**一个算法的评价主要从[时间复杂度](https://baike.baidu.com/item/时间复杂度)和[空间复杂度](https://baike.baidu.com/item/空间复杂度)来考虑。**

#### 时间复杂度

> **时间复杂度：假设存在函数g，使得算法处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)**  ————百度百科

算法的时间复杂度是指执行算法所需要的工作量。一般用**大O记法**。

但从定义理解很有困难，直接从例子中理解。

**举例**：1  ，**记为**：O(1) ——单一自然数，整数，小数等计算机都只计算一次，所以是O(1)

**举例**：$6n+9$ ，**记为**：O(n) ——假如n从0变化到100，计算机会执行100次，所以是O(n)

**举例**：$4n^2+9n+6$，**记为**：O($n^2$) ——并不是O($n^2$) +O(n)+O(1) ，这里省略后两项

**算法时间复杂度分析并不是细致的分析，而是大概的分析**，比如3$n^2$和100$n^2$是同等数量级O($n^2$) ，举例中$4n^2+9n+6$会不考虑系数和低级的时间复杂度，**因为对算法快慢的主要是高级时间复杂度**

**举例**：$2log_2^n+3$，**记为**：O(logn) 

**举例**：$6n+2nlog_2^n+5$，**记为**：O(nlogn) 

**举例**：$n^3+n^2+5n+1$，**记为**：O($n^3$) 

**举例**：$2^n$，**记为**：O($2^n$) 

**举例**：$n!$，**记为**：O($n!$) 

**举例**：$n^n$，**记为**：O($n^n$) 

所消耗的时间从小到大**——很重要**

**O(1) < O(logn) < O(n) < O(nlogn) < O($n^2$) < O($n^3$) < O($2^n$) < O(n!) < O($n^n$)**

#### 时间复杂度基本计算规则

1. 基本操作，即只有常数项，认为其时间复杂度为O(1)
2. 顺序结构，时间复杂度按**加法**进行计算
3. 循环结构，时间复杂度按**乘法**进行计算
4. 分支结构，时间复杂度**取最大值**
5. 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略
6. 在没有特殊说明时，我们所分析的算法的时间复杂度都是指**最坏时间复杂度**

#### 最坏时间复杂度

时间复杂度分为：

- 算法完成工作最少需要多少基本操作，即**最优时间复杂度**
- 算法完成工作最多需要多少基本操作，即**最坏时间复杂度**
- 算法完成工作平均需要多少基本操作，即**平均时间复杂度**

为了保证算法安全稳定性，一般只关注最坏时间复杂度。

#### 对思考问题时间复杂度的计算

```
# 第一种的分析
for a in range(0, 1000):  # 循环
    for b in range(0, 1000):  # 循环
        for c in range(0, 1000):  # 循环
            if a*a + b*b == c*c and a + b + c == 1000: # 分支
                print("a:%d,b:%d,c:%d" % (a, b, c)) 
```

循环操作按乘法：O(n)$*$O(n)$*$O(n)=O($n^3$)三次循环，一次顺序，省略次要项

```
# 第二种的分析
for a in range(0, 1000):  # 循环
    for b in range(0, 1000):  # 循环
        c = 1000 - a - b   # 顺序
        if a*a + b*b == c*c:  # 顺序
            print("a:%d,b:%d,c:%d" % (a, b, c)) 
```

循环操作按乘法：O(n)$*$O(n)$*$O(1+1)=O($ n^2 $)两次循环，两次顺序，省略次要项

因此第二种好，O($n^2 $)<O($n^3$)

#### 空间复杂度

评价算法优劣的第二种方法，同时间复杂度相比空间复杂度分析要简单的多，指的是算法需要消耗的内存空间。